<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yvonsoft Arcade</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=all" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <style>
        /* ==================================== */
        /* 1. STYLES DE BASE (DARK MODE) */
        /* ==================================== */
        html, body {
            height: 100%;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212; 
            color: #f0f0f0; 
            margin: 0;
            padding: 0; 
            display: flex;
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh;
            text-align: center;
        }
        .container {
            width: 100%;
            max-width: 650px;
            background: #1e1e1e; 
            padding: 30px;
            border-radius: 16px; 
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6); 
            border: 1px solid #333333; 
            margin: 15px auto; 
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
        }
        .hidden { display: none !important; }

        /* Styles g√©n√©raux */
        h1 { font-size: 38px; font-weight: 900; color: #ffffff; margin-bottom: 5px; }
        .level-title { font-size: 26px; font-weight: 700; color: #aaaaaa; margin-bottom: 20px; }
        .subtitle { color: #888888; }
        
        /* Boutons et Inputs */
        .action-buttons { 
            display: flex; 
            justify-content: center; 
            gap: 15px; 
            margin-top: 30px; 
            flex-wrap: wrap; 
        }
        .new-game-button, .change-profile-btn {
            background-color: #00bcd4; color: #1a1a1a; border-radius: 10px;
            padding: 12px 25px; border: none; font-weight: 700;
            cursor: pointer; transition: background-color 0.2s, transform 0.1s;
        }
        .new-game-button:hover, .change-profile-btn:hover {
            background-color: #0097a7;
        }
        .reset-button { background-color: #f44336 !important; color: white !important; }

        .input-area { display: flex; gap: 12px; margin-bottom: 35px; }
        .input-area input { 
            flex-grow: 1; padding: 18px 20px; border: 1px solid #444; 
            border-radius: 10px; font-size: 18px; color: #f0f0f0;
            background-color: #333333; transition: border-color 0.3s, box-shadow 0.3s; 
        }

        /* ==================================== */
        /* 2. STYLES DE SNAKE */
        /* ==================================== */
        #snakeGameArea .container {
            max-width: 580px; 
            padding: 20px; 
            background: #1a1a1a;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8), 0 0 20px rgba(0, 188, 212, 0.2);
        }
        #snakeGameArea h1 {
            color: #4caf50;
            margin-bottom: 10px;
        }
        #gameBoard {
            border: 3px solid #00bcd4; 
            background-color: #1a1a1a;
            box-shadow: 0 0 15px rgba(0, 188, 212, 0.6);
            margin-bottom: 20px;
            display: block; 
        }
        .snake-score {
            font-size: 30px; 
            font-weight: 900;
            color: #ffeb3b;
            margin-bottom: 15px;
        }
        .snake-instructions {
            margin-top: 15px;
            color: #aaaaaa;
            font-weight: 500;
        }
        .pause-message {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            font-weight: bold;
            border-radius: 5px;
            z-index: 10;
        }
        
        /* Styles de tableau S√©mantique */
        .results {
            max-height: 250px;
            overflow-y: auto; 
            border: 1px solid #444;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        /* Styles de profil, etc. (inchang√©s) */
        .home-button {
             background-color: #4caf50; 
             color: white; 
             padding: 8px 15px;
             border: none;
             border-radius: 10px;
             cursor: pointer;
             font-weight: 600;
             margin-right: 10px;
             transition: background-color 0.2s;
        }
        #profileArea {
            width: 100%;
            max-width: 650px;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 25px;
            background-color: #2a2a2a;
            border-radius: 16px;
            border: 1px solid #3a3a3a;
        }
    </style>
</head>
<body>
    
    <div id="profileArea" class="hidden">
        <div>
            <button class="home-button" onclick="goToWelcomeScreen()"><i class="fa-solid fa-house"></i> Accueil</button>
            <i class="fa-solid fa-user-astronaut" style="color:#00bcd4; margin-right: 10px;"></i> Joueur : <span id="profileName">--</span>
        </div>
        <button class="change-profile-btn" onclick="resetProfile()">Changer de Pseudo</button>
    </div>

    <div class="container" id="welcomeScreen">
        <h2>Yvonsoft Arcade</h2>
        <p class="subtitle">Bienvenue ! Choisissez un jeu pour commencer.</p>
        <div class="game-selection" style="display: flex; justify-content: center; gap: 20px; margin-top: 30px;">
            
            <div class="game-card" onclick="startSemantique()" style="background-color: #2a2a2a; padding: 25px; border-radius: 12px; cursor: pointer; width: 45%; transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s; border: 2px solid #333;">
                <i class="icon fa-solid fa-brain" style="color:#ff9800; font-size: 40px;"></i>
                <h3>S√©mantique Infini</h3>
                <p class="subtitle">Le jeu de proximit√© s√©mantique.</p>
            </div>
            
            <div class="game-card" onclick="startSnake()" style="background-color: #2a2a2a; padding: 25px; border-radius: 12px; cursor: pointer; width: 45%; transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s; border: 2px solid #333;">
                <i class="icon fa-solid fa-snake" style="color:#4caf50; font-size: 40px;"></i>
                <h3>Snake</h3>
                <p class="subtitle">Le classique jeu du serpent.</p>
            </div>
        </div>
    </div>
    
    <div class="container hidden" id="loginScreen">
        <h2>D√©marrez votre session</h2>
        <p class="subtitle" style="margin-bottom: 30px;">Veuillez entrer votre pseudo pour acc√©der aux jeux.</p>
        <input type="text" id="usernameInput" placeholder="Votre Pseudo (max 12 caract√®res)" maxlength="12" onkeydown="if(event.key === 'Enter') saveProfile()">
        <button class="new-game-button" onclick="saveProfile()">Acc√©der √† l'Arcade</button>
    </div>

    <div id="gameArea" class="hidden">
        
        <div class="main-game-area hidden" id="semantiqueGameArea">
            <div class="container" id="gameContainer">
                <h1>S√©mantique Infini</h1>
                <div class="level-title" id="levelTitle">Mot Secret du Jour N¬∞1</div>
                <p class="subtitle">Trouvez le mot secret en vous basant sur la proximit√© s√©mantique.</p>
                <div id="bestScoreDisplay" style="display:flex; justify-content:center;">
                     <i class="fa-solid fa-trophy" style="color:#ffeb3b;"></i> 
                     Meilleur Score (local) : <span id="bestScoreValue">--</span> tentatives
                </div>
                <div class="attempt-counter" style="font-size: 18px; font-weight: 600; margin-bottom: 15px; color: #f0f0f0;">
                    Tentatives : <span id="attemptCount">0</span>
                </div>
                <div class="action-buttons" id="challengeExitArea">
                    <button class="new-game-button challenge-exit-button hidden" id="exitChallengeButton" onclick="quitterDefi()">
                        <i class="fa-solid fa-arrow-left"></i> Revenir au Mode Normal
                    </button>
                </div>
                <div class="input-area">
                    <input type="text" id="wordInput" placeholder="Saisir un mot ici..." autofocus onkeydown="if(event.key === 'Enter') proposerMot()">
                    <button class="new-game-button" onclick="proposerMot()" id="proposeButton">Proposer</button>
                </div>
                <div class="error-message" id="errorMessage" style="color:#f44336; margin-bottom: 15px; font-weight: 500;"></div>
                <div class="results">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background-color: #2a2a2a;">
                                <th style="width: 45%; padding: 10px; padding-left: 15px; text-align: left; border-bottom: 2px solid #3a3a3a;">Mot Propos√©</th>
                                <th style="width: 25%; padding: 10px; border-bottom: 2px solid #3a3a3a;">Score (0-1000)</th>
                                <th style="width: 30%; padding: 10px; border-bottom: 2px solid #3a3a3a;">Temp√©rature</th>
                            </tr>
                        </thead>
                        <tbody id="scoreTableBody" style="font-size: 14px;">
                        </tbody>
                    </table>
                </div>
                <div class="action-buttons" id="normalGameActionButtons">
                    <button class="new-game-button" id="nextLevelButton" onclick="passerAuMotSuivant()">Passer au Mot Suivant</button>
                    <button class="new-game-button reset-button" onclick="resetProgress()">R√©initialiser la Progression</button>
                </div>
            </div>
            
            <div class="chart-container social-panel" id="chartContainer" style="background: #1e1e1e; border-radius: 16px; margin-top: 25px;">
                <h2 style="font-size: 24px; font-weight: 800; margin-bottom: 15px;">Progression du Score</h2>
                <canvas id="scoreChart"></canvas>
            </div>
            <div id="socialPanel" class="social-panel" style="background: #1e1e1e; border-radius: 16px; margin-top: 25px;">
                <h2 style="font-size: 24px; font-weight: 800; margin-bottom: 15px;"><i class="fa-solid fa-users" style="color:#ff9800;"></i> Jouer en Ligne / Amis (Simul√©)</h2>
                <div class="search-input-area" style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <input type="text" id="friendSearchInput" placeholder="Rechercher un pseudo (Ex: Joueur2)" style="padding: 10px;">
                    <button class="new-game-button" onclick="searchFriend()" style="padding: 10px 15px;"><i class="fa-solid fa-magnifying-glass"></i> Rechercher</button>
                </div>
                <div id="searchResults" style="text-align: left; padding: 0 10px;">
                    <p class="social-info" style="color:#888;">Cherchez votre propre pseudo ou "Joueur2" pour voir le bouton "D√©fier".</p>
                </div>
            </div>
        </div>
        
        <div class="main-game-area hidden" id="snakeGameArea">
            <div class="container">
                <h1>Snake üêç</h1>
                <p class="snake-score">Score: <span id="snakeScore">0</span></p>
                <div style="position: relative; width: 500px; height: 500px;">
                    <canvas id="gameBoard"></canvas>
                    <div id="snakePauseMessage" class="pause-message">
                        <p style="margin: 5px;">Utilisez les fl√®ches pour commencer √† jouer !</p>
                        <p style="font-size: 18px; font-weight: 400; color: #ffeb3b;">(Ou cliquez sur Nouvelle Partie)</p>
                    </div>
                </div>
                <div class="action-buttons">
                    <button class="new-game-button" onclick="startGame()"><i class="fa-solid fa-play"></i> Nouvelle Partie</button>
                    <button class="new-game-button reset-button" onclick="endGame()"><i class="fa-solid fa-stop"></i> Arr√™ter le Jeu</button>
                </div>
                <p class="snake-instructions">La partie d√©marre √† la premi√®re pression sur une **fl√®che**.</p>
            </div>
        </div>
        
        <div class="easter-egg-message" id="easterEggMessage" style="display:none; color: white; background: #f44336; padding: 40px; border-radius: 15px;">
            T'es b√™te ou quoi ? üí©
            <div style="margin-top: 20px;">
                 <button class="new-game-button" onclick="nouvellePartie()">Nouvelle Partie</button>
            </div>
        </div>

    </div>

    <script>
        // ====================================================================
        // GESTION DU PROFIL & DE L'INTERFACE GLOBALE (Inchangement)
        // ====================================================================
        let username = "";
        let currentGame = null; 

        function loadProfile() {
            username = localStorage.getItem('semantique_infini_username');
            if (username) {
                document.getElementById('profileName').textContent = username;
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('profileArea').classList.remove('hidden');
                document.getElementById('gameArea').classList.remove('hidden');
                
                goToWelcomeScreen();
            } else {
                goToLoginScreen();
            }
        }
        
        function goToWelcomeScreen() {
             document.getElementById('welcomeScreen').classList.remove('hidden');
             document.getElementById('loginScreen').classList.add('hidden');
             document.getElementById('profileArea').classList.remove('hidden');
             document.getElementById('gameArea').classList.add('hidden');
             
             document.getElementById('semantiqueGameArea').classList.add('hidden');
             document.getElementById('snakeGameArea').classList.add('hidden');
             
             if (gameLoop) endGame(); 
             document.removeEventListener('keydown', handleKeyPress); 

             if (currentGame === 'snake') {
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                 gameLoop = null; 
             }
             currentGame = null;
        }

        function goToLoginScreen() {
             document.getElementById('welcomeScreen').classList.add('hidden');
             document.getElementById('loginScreen').classList.remove('hidden');
             document.getElementById('profileArea').classList.add('hidden');
             document.getElementById('gameArea').classList.add('hidden');
             document.getElementById('usernameInput').focus();
        }


        function saveProfile() {
            const input = document.getElementById('usernameInput');
            let newUsername = input.value.trim();

            if (newUsername.length < 3) {
                alert("Le pseudo doit contenir au moins 3 caract√®res.");
                return;
            }
            if (newUsername.length > 12) {
                 newUsername = newUsername.substring(0, 12); 
            }
            
            localStorage.setItem('semantique_infini_username', newUsername);
            loadProfile(); 
        }
        
        function resetProfile() {
            if (confirm(`√ätes-vous s√ªr de vouloir changer de pseudo ? (La progression locale de S√©mantique Infini ne sera pas effac√©e)`)) {
                localStorage.removeItem('semantique_infini_username');
                document.getElementById('usernameInput').value = "";
                loadProfile();
            }
        }

        // ====================================
        // D√âMARRAGE DES JEUX
        // ====================================
        
        function startSemantique() {
            if (!username) {
                goToLoginScreen();
                return;
            }
            currentGame = 'semantique';
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('semantiqueGameArea').classList.remove('hidden');
            document.getElementById('snakeGameArea').classList.add('hidden');
            document.getElementById('gameArea').classList.remove('hidden');
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (gameLoop) {
                clearInterval(gameLoop);
                gameLoop = null;
            }

            document.removeEventListener('keydown', handleKeyPress); 

            chargerProgression(); 
        }

        function startSnake() {
            if (!username) {
                 goToLoginScreen();
                 return;
            }
            currentGame = 'snake';
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('semantiqueGameArea').classList.add('hidden');
            document.getElementById('snakeGameArea').classList.remove('hidden');
            document.getElementById('gameArea').classList.remove('hidden');
            
            initializeSnake(); 
            resetSnakeGame(); 
        }

        // ====================================================================
        // LOGIQUE DU JEU SNAKE (MODIFICATIONS IMPORTANTES)
        // ====================================================================
        
        const GRID_SIZE = 20;
        const TILE_SIZE = 25; 
        const INITIAL_SPEED = 150; 
        const INITIAL_FOOD_COUNT = 20;
        // La taille de d√©part est de 3 segments (t√™te incluse)
        const INITIAL_LENGTH = 3; 

        let snake = [];
        let foodList = [];
        let dx = TILE_SIZE; 
        let dy = 0; 
        let directionQueue = []; // NOUVEAU: Pour la r√©activit√© des touches
        let gameLoop = null; 
        let animationFrameId = null; 
        let speed = INITIAL_SPEED; 
        let score = 0;
        let isPaused = true; 
        let step = 0; // Progression d'interpolation [0 √† speed]
        let canvas, ctx;
        
        function initializeSnake() {
             canvas = document.getElementById('gameBoard');
             canvas.width = GRID_SIZE * TILE_SIZE;
             canvas.height = GRID_SIZE * TILE_SIZE;
             ctx = canvas.getContext('2d');
             
             document.removeEventListener('keydown', handleKeyPress); 
             document.addEventListener('keydown', handleKeyPress);
        }

        function resetSnakeGame() {
            if (gameLoop) clearInterval(gameLoop);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop = null;
            animationFrameId = null;
            
            isPaused = true; 
            speed = INITIAL_SPEED;
            score = 0;
            document.getElementById('snakeScore').textContent = score;

            // Position initiale du serpent avec 3 segments
            const startX = 10 * TILE_SIZE;
            const startY = 10 * TILE_SIZE;
            snake = [];
            for(let i = 0; i < INITIAL_LENGTH; i++) {
                snake.push({ 
                    x: startX - i * TILE_SIZE, 
                    y: startY, 
                    prevX: startX - (i + 1) * TILE_SIZE, 
                    prevY: startY 
                });
            }
            
            dx = TILE_SIZE; 
            dy = 0;
            directionQueue = [];
            step = 0; 
            
            foodList = [];
            for (let i = 0; i < INITIAL_FOOD_COUNT; i++) {
                generateFood(); 
            }
            
            drawGame(); 
            
            document.getElementById('snakePauseMessage').style.display = 'flex';
        }
        
        function startGame() {
             if (!isPaused) return;
             
             isPaused = false;
             document.getElementById('snakePauseMessage').style.display = 'none';
             
             // R√©initialiser le timer si l'on d√©marre apr√®s une pause/fin
             if (!gameLoop) {
                 gameLoop = setInterval(tick, speed); 
             }
             
             animationLoop(performance.now()); 
        }
        
        function endGame() {
            if (gameLoop) {
                clearInterval(gameLoop);
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameLoop = null;
            animationFrameId = null;
            isPaused = true;
            
            resetSnakeGame(); 
        }
        
        // GESTION DES TOUCHES (avec file d'attente)
        function handleKeyPress(event) {
            if (currentGame !== 'snake') return; 

            const KEY_LEFT = 37;
            const KEY_UP = 38;
            const KEY_RIGHT = 39;
            const KEY_DOWN = 40;
            
            const keyPressed = event.keyCode;
            
            if (keyPressed >= KEY_LEFT && keyPressed <= KEY_DOWN) {
                 event.preventDefault(); 
            }
            
            if (isPaused && keyPressed >= KEY_LEFT && keyPressed <= KEY_DOWN) {
                 // Si c'est le premier mouvement, on l'applique directement et on d√©marre
                 const newDirection = getDirectionFromKey(keyPressed);
                 if (newDirection) {
                     directionQueue.push(newDirection);
                 }
                 startGame();
                 return; 
            }
            
            if (isPaused) return;

            const newDirection = getDirectionFromKey(keyPressed);

            if (newDirection) {
                // Si la file est vide, on v√©rifie la direction actuelle (dx, dy)
                const currentDx = dx;
                const currentDy = dy;
                
                // Si la file n'est pas vide, on v√©rifie la derni√®re direction en file
                const lastDirection = directionQueue.length > 0 ? directionQueue[directionQueue.length - 1] : { dx: currentDx, dy: currentDy };
                
                // Emp√™che le retournement imm√©diat (ex: aller √† gauche si on va √† droite)
                if ((newDirection.dx === -lastDirection.dx && newDirection.dx !== 0) || 
                    (newDirection.dy === -lastDirection.dy && newDirection.dy !== 0)) {
                    // Direction invalide (retournement)
                    return; 
                }

                // Ajoute la nouvelle direction √† la file
                if (directionQueue.length < 2) { 
                    directionQueue.push(newDirection);
                }
            }
        }
        
        function getDirectionFromKey(keyPressed) {
            const KEY_LEFT = 37;
            const KEY_UP = 38;
            const KEY_RIGHT = 39;
            const KEY_DOWN = 40;
            
            if (keyPressed === KEY_LEFT) return { dx: -TILE_SIZE, dy: 0 };
            if (keyPressed === KEY_UP) return { dx: 0, dy: -TILE_SIZE };
            if (keyPressed === KEY_RIGHT) return { dx: TILE_SIZE, dy: 0 };
            if (keyPressed === KEY_DOWN) return { dx: 0, dy: TILE_SIZE };
            return null;
        }


        function generateFood() {
            let newFood;
            let occupied;
            do {
                newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE,
                    y: Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE
                };
                
                occupied = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) || 
                           foodList.some(item => item.x === newFood.x && item.y === newFood.y);

            } while (occupied);
            
            foodList.push(newFood);
        }
        
        
        function drawGame() {
            // 1. Dessiner le fond (Grille Damier)
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    ctx.fillStyle = (i + j) % 2 === 0 ? '#1f1f1f' : '#232323'; 
                    ctx.fillRect(i * TILE_SIZE, j * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // 2. Dessiner la nourriture 
            foodList.forEach(food => {
                ctx.fillStyle = '#f44336'; 
                ctx.shadowColor = '#f44336';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(food.x + TILE_SIZE / 2, food.y + TILE_SIZE / 2, TILE_SIZE / 2 - 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.shadowBlur = 0;
            
            // 3. Dessiner le serpent (avec interpolation)
            // Calculer le facteur d'interpolation (doit √™tre entre 0 et 1)
            let interPolationFactor = Math.min(1, step / speed);
            
            // Si en pause, l'interpolation est √† 0 (position statique)
            if (isPaused) {
                interPolationFactor = 0;
            }

            snake.forEach((segment, index) => {
                
                // Utiliser la position interpol√©e entre la position pr√©c√©dente et la position actuelle (future)
                let renderX = segment.prevX + (segment.x - segment.prevX) * interPolationFactor;
                let renderY = segment.prevY + (segment.y - segment.prevY) * interPolationFactor;
                
                // Style
                if (index === 0) {
                    ctx.fillStyle = '#00bcd4'; 
                    ctx.shadowColor = '#00bcd4';
                    ctx.shadowBlur = 5;
                } else {
                    ctx.fillStyle = '#4caf50'; 
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
                
                // Dessin (margin = 0 pour un rendu solide)
                const margin = 0; 
                ctx.fillRect(renderX + margin, renderY + margin, TILE_SIZE - margin * 2, TILE_SIZE - margin * 2);
            });
            
            ctx.shadowBlur = 0;
        }

        // Boucle d'animation fluide
        let lastFrameTime = 0;
        function animationLoop(timestamp) {
            if (isPaused) return;

            const elapsed = timestamp - lastFrameTime;

            // Mettre √† jour l'√©tape d'interpolation
            step += elapsed;
            
            // Si le pas d√©passe la dur√©e d'un tick, on le plafonne pour √©viter les saccades
            if (step > speed) {
                step = speed; 
            }
            
            drawGame();
            lastFrameTime = timestamp;
            animationFrameId = requestAnimationFrame(animationLoop);
        }


        // Logique de jeu (mise √† jour des positions par cases)
        function tick() {
            if (isPaused) return;

            // 1. Appliquer la prochaine direction en file, si elle existe
            if (directionQueue.length > 0) {
                const newDirection = directionQueue.shift();
                dx = newDirection.dx;
                dy = newDirection.dy;
            }
            
            // 2. R√©initialiser l'√©tape de l'animation
            step = 0; 

            // 3. Enregistrer l'ancienne position pour chaque segment
            snake.forEach(segment => {
                segment.prevX = segment.x;
                segment.prevY = segment.y;
            });

            // 4. Calculer la nouvelle t√™te
            // NOTE : head ne devient PAS un nouvel objet, on met √† jour le premier segment
            const head = snake[0]; 
            const newHeadX = head.x + dx;
            const newHeadY = head.y + dy;
            
            // 5. V√©rification des collisions

            // Collision avec les murs
            if (
                newHeadX < 0 || newHeadX >= canvas.width ||
                newHeadY < 0 || newHeadY >= canvas.height
            ) {
                endGame(); 
                return;
            }
            
            // Collision avec le corps (v√©rification √† partir du 3√®me segment)
            for (let i = 2; i < snake.length; i++) {
                if (newHeadX === snake[i].x && newHeadY === snake[i].y) {
                    endGame();
                    return;
                }
            }

            // 6. Mise √† jour du serpent (Mouvement)
            const tail = snake[snake.length - 1];
            let foodEaten = false;
            
            // V√©rification de la nourriture (collision avec n'importe quel morceau)
            const foodIndex = foodList.findIndex(food => newHeadX === food.x && newHeadY === food.y);
            
            if (foodIndex !== -1) {
                foodEaten = true;
                score++;
                document.getElementById('snakeScore').textContent = score;
                
                foodList.splice(foodIndex, 1);
                generateFood();
            } 
            
            // D√©placer les segments (de la queue vers l'avant)
            for (let i = snake.length - 1; i > 0; i--) {
                snake[i].x = snake[i-1].x;
                snake[i].y = snake[i-1].y;
            }
            
            // Ajouter la nouvelle position √† la t√™te
            head.x = newHeadX;
            head.y = newHeadY;

            // Si nourriture mang√©e, ajouter un nouveau segment (ancienne queue)
            if (foodEaten) {
                snake.push(tail); 
            }

            // 7. Acc√©l√©ration (R√©duction de l'intervalle)
            if (foodEaten) {
                if (speed > 50) {
                     speed -= 1; 
                     clearInterval(gameLoop);
                     gameLoop = setInterval(tick, speed);
                }
            }
        }
        
        // ====================================================================
        // LOGIQUE DU JEU S√âMANTIQUE (Inchangement)
        // ====================================================================
        
        const SEQUENCE_MOTS_SECRETS = [
            "chien", "ordinateur", "voyage", "musique", "montagne", 
            "livre", "amiti√©", "soleil", "chocolat", "futur", "maison", "pluie", "argent"
        ];
        const ASSOCIATIONS = {
            "chien": { "chat": 950, "animal": 800, "fidelite": 650, "promenade": 720, "loup": 780, "aboyer": 500, "croquette": 550 },
            "ordinateur": { "clavier": 900, "souris": 850, "programme": 750, "travail": 600, "internet": 820, "code": 700, "ecran": 880 },
            "voyage": { "avion": 900, "vacances": 850, "aventure": 700, "passeport": 650, "exploration": 780, "deplacement": 600, "destination": 830 },
            "musique": { "guitare": 900, "chanter": 850, "concert": 700, "rythme": 780, "emotion": 550, "instrument": 820, "note": 760 },
            "montagne": { "ski": 900, "neige": 850, "randonnee": 750, "sommet": 600, "froid": 550, "altitude": 700, "alpinisme": 780 },
            "livre": { "lecture": 920, "page": 850, "ecrire": 750, "auteur": 600, "roman": 800, "histoire": 700, "bibliotheque": 790 },
            "amiti√©": { "amour": 700, "famille": 650, "confiance": 850, "partage": 750, "lien": 680, "relation": 720, "joie": 600 },
            "soleil": { "chaleur": 900, "plage": 750, "√©t√©": 850, "lumiere": 800, "astre": 780, "jour": 700, "ciel": 650 },
            "chocolat": { "cacao": 900, "dessert": 850, "sucre": 700, "gourmandise": 820, "noir": 780, "gateau": 750, "douceur": 600 },
            "futur": { "temps": 900, "demain": 850, "espoir": 700, "science": 650, "prochain": 780, "technologie": 750 },
            "maison": { "famille": 800, "appartement": 950, "toit": 700, "confort": 650, "jardin": 750, "immeuble": 880, "logement": 920 },
            "pluie": { "parapluie": 900, "eau": 850, "nuage": 750, "goutte": 800, "tempete": 650, "averse": 780, "ciel": 700 },
            "argent": { "richesse": 900, "banque": 850, "travail": 750, "payer": 800, "monnaie": 950, "economie": 820, "fortune": 780 }
        };
        
        let currentLevel = 0;
        let motSecret = "";
        let essais = [];
        let totalEssais = 0;
        let partieTerminee = false;
        let chartInstance;
        const MOT_DEFI = "myst√®re"; 
        let isChallengeMode = false;

        
        function chargerProgression() {
            if (currentGame !== 'semantique') return;
            
            document.getElementById('easterEggMessage').style.display = 'none';

            const exitButton = document.getElementById('exitChallengeButton');
            const normalActions = document.getElementById('normalGameActionButtons');
            const gameContainer = document.getElementById('gameContainer');
            const chartContainer = document.getElementById('chartContainer');
            const socialPanel = document.getElementById('socialPanel');

            if (isChallengeMode) {
                motSecret = MOT_DEFI;
                document.getElementById('levelTitle').textContent = `‚öîÔ∏è D√©fi en Ligne : Mot ${MOT_DEFI.toUpperCase()} ‚öîÔ∏è`;
                exitButton.classList.remove('hidden');
                normalActions.classList.add('hidden');
                document.getElementById('bestScoreDisplay').classList.add('hidden');
                return;
            }
            
            gameContainer.classList.remove('hidden');
            chartContainer.classList.remove('hidden');
            socialPanel.classList.remove('hidden');

            exitButton.classList.add('hidden');
            normalActions.classList.remove('hidden');

            const savedLevel = localStorage.getItem('semantique_infini_level');
            if (savedLevel !== null) {
                currentLevel = parseInt(savedLevel);
            }
            
            if (currentLevel >= SEQUENCE_MOTS_SECRETS.length) {
                currentLevel = 0; 
            }

            const savedEssais = localStorage.getItem(`semantique_infini_essais_${currentLevel}`);
            if (savedEssais) {
                essais = JSON.parse(savedEssais);
                totalEssais = essais.length;
                partieTerminee = essais.some(e => e.score === 1000);
            } else {
                essais = [];
                totalEssais = 0;
                partieTerminee = false;
            }

            motSecret = SEQUENCE_MOTS_SECRETS[currentLevel];
            
            document.getElementById('levelTitle').textContent = `Mot Secret du Jour N¬∞${currentLevel + 1}`; 
            
            mettreAJourUIJeu(partieTerminee);
            afficherResultats();
            afficherMeilleurScore(); 
            document.getElementById('wordInput').focus();
        }

        function sauvegarderEssais() {
            if (isChallengeMode) return; 
            localStorage.setItem(`semantique_infini_essais_${currentLevel}`, JSON.stringify(essais));
            localStorage.setItem('semantique_infini_level', currentLevel.toString());
        }

        function mettreAJourUIJeu(trouve) {
            const input = document.getElementById('wordInput');
            const proposeButton = document.getElementById('proposeButton');
            const nextButton = document.getElementById('nextLevelButton');
            
            input.disabled = trouve;
            proposeButton.disabled = trouve;
            
            if (isChallengeMode && trouve) {
                nextButton.textContent = "Terminer le D√©fi";
                nextButton.classList.remove('disabled-button');
                nextButton.onclick = terminerDefi;
                nextButton.disabled = false;
                
                document.getElementById('normalGameActionButtons').classList.add('hidden');
                document.getElementById('exitChallengeButton').classList.remove('hidden');
                return;
            }
            
            if (!isChallengeMode) {
                 document.getElementById('normalGameActionButtons').classList.remove('hidden');
                 document.getElementById('exitChallengeButton').classList.add('hidden'); 
            }

            if (trouve) {
                document.getElementById('levelTitle').textContent = `Mot Secret du Jour N¬∞${currentLevel + 1} : ${motSecret.toUpperCase()} üéâ`;
                sauvegarderMeilleurScore(); 
                nextButton.textContent = (currentLevel + 1 < SEQUENCE_MOTS_SECRETS.length) ? "Passer au Mot Suivant" : "Recommencer la S√©rie";
                nextButton.classList.remove('disabled-button');
                nextButton.onclick = passerAuMotSuivant; 
                nextButton.disabled = false;
            } else {
                 if (!isChallengeMode) {
                     document.getElementById('levelTitle').textContent = `Mot Secret du Jour N¬∞${currentLevel + 1}`;
                 }
                nextButton.textContent = "Passer au Mot Suivant";
                nextButton.classList.add('disabled-button');
                nextButton.onclick = passerAuMotSuivant;
                nextButton.disabled = true;
            }
        }
        
        function proposerMot() {
            if (currentGame !== 'semantique') return;
            
            if (!username) {
                alert("Veuillez d'abord entrer un pseudo pour commencer !");
                document.getElementById('wordInput').blur();
                document.getElementById('usernameInput').focus();
                return;
            }
            
            const input = document.getElementById('wordInput');
            const errorMessage = document.getElementById('errorMessage');
            const motOriginal = input.value.trim().toLowerCase();
            input.value = '';
            errorMessage.textContent = '';

            if (!motOriginal) return;
            if (partieTerminee) return;

            if (motOriginal === "caca") {
                document.getElementById('semantiqueGameArea').classList.add('hidden');
                document.getElementById('profileArea').classList.add('hidden');
                document.getElementById('easterEggMessage').style.display = 'block';
                mettreAJourUIJeu(true);
                return;
            }

            if (essais.some(e => e.original === motOriginal || e.mot === motOriginal)) {
                errorMessage.textContent = `Le mot '${motOriginal}' a d√©j√† √©t√© propos√©.`;
                return;
            }
            if (motOriginal.length < 3) {
                 errorMessage.textContent = "Le mot doit faire au moins 3 lettres.";
                return;
            }

            const motCorrig√© = corrigerMot(motOriginal);
            const estCorrig√© = motCorrig√© !== motOriginal;
            
            if (estCorrig√©) {
                errorMessage.textContent = `Mot corrig√© automatiquement : '${motOriginal}' ‚Üí '${motCorrig√©}'.`;
            }

            totalEssais++;
            const score = calculerScore(motCorrig√©);
            const victoire = score === 1000;

            essais.push({
                mot: motCorrig√©,
                score: score,
                original: motOriginal,
                corrige: estCorrig√©,
                joueur: username 
            });

            sauvegarderEssais();
            afficherResultats();

            if (victoire) {
                partieTerminee = true;
                mettreAJourUIJeu(true);
                return;
            }
            
            document.getElementById('wordInput').focus();
        }
        
        function nouvellePartie() {
            document.getElementById('semantiqueGameArea').classList.remove('hidden');
            document.getElementById('profileArea').classList.remove('hidden');
            document.getElementById('easterEggMessage').style.display = 'none';
            isChallengeMode = false; 
            chargerProgression(); 
        }

        function levenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase(); s2 = s2.toLowerCase();
            const costs = new Array();
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i == 0) { costs[j] = j; } 
                    else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) != s2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

        function corrigerMot(mot) {
            let meilleureCorrection = mot;
            let distanceMin = Infinity;
            
            let motsAVerifier = [motSecret];
            if (ASSOCIATIONS[motSecret] && !isChallengeMode) {
                motsAVerifier = motsAVerifier.concat(Object.keys(ASSOCIATIONS[motSecret]));
            }
            
            for (let motValide of motsAVerifier) {
                const distance = levenshteinDistance(mot, motValide);
                if (distance < distanceMin) {
                    distanceMin = distance;
                    meilleureCorrection = motValide;
                }
            }

            if (distanceMin <= 2 && distanceMin > 0) {
                return meilleureCorrection;
            }
            return mot;
        }

        function calculerScore(motPropose) {
            if (motPropose === motSecret) return 1000;
            if (isChallengeMode || !ASSOCIATIONS[motSecret] || !ASSOCIATIONS[motSecret][motPropose]) {
                let score = (Math.random() * 80) + 1;
                return parseFloat(score.toFixed(2));
            }
            return ASSOCIATIONS[motSecret][motPropose];
        }

        function determinerTemp(score) {
            if (score === 1000) return { text: "TROUV√â ! üèÜ", class: "temp-win" };
            if (score >= 900) return { text: "√âBULLITION ‚ò¢Ô∏è", class: "score-900" };
            if (score >= 700) return { text: "CHAUD BOUILLANT üî•", class: "score-700" };
            if (score >= 500) return { text: "Chaud üü†", class: "score-500" };
            if (score >= 100) return { text: "Ti√®de üü°", class: "score-100" };
            return { text: "Glace üßä", class: "score-0" };
        }

        function getScoreColorClass(score) {
            if (score === 1000) return 'score-900'; 
            if (score >= 900) return 'score-900';
            if (score >= 700) return 'score-700';
            if (score >= 500) return 'score-500';
            if (score >= 100) return 'score-100';
            return 'score-0';
        }

        function getBorderColor(tempClass) {
            if (tempClass === 'temp-win') return '#4caf50'; 
            if (tempClass === 'score-900') return '#ffeb3b';
            if (tempClass === 'score-700') return '#ff9800';
            if (tempClass === 'score-500') return '#f0f0f0';
            return '#666666';
        }

        
        function afficherResultats() {
            const tbody = document.getElementById('scoreTableBody');
            const tempFragment = document.createDocumentFragment();
            
            const essaisTries = [...essais].sort((a, b) => b.score - a.score);
            
            tbody.innerHTML = ''; 
            
            document.getElementById('attemptCount').textContent = totalEssais;

            essaisTries.forEach(essai => {
                const temp = determinerTemp(essai.score);
                const scoreColorClass = getScoreColorClass(essai.score);
                const row = document.createElement('tr');
                
                let motDisplay = essai.mot.charAt(0).toUpperCase() + essai.mot.slice(1);
                if (essai.corrige) {
                    motDisplay += `<span class="correction-text" style="font-size: 11px; color: #888;"> (corrig√© de ${essai.original})</span>`;
                }
                const motCell = row.insertCell();
                motCell.innerHTML = (essai.score > 700) ? `<strong>${motDisplay}</strong>` : motDisplay;
                
                motCell.style.borderLeftColor = getBorderColor(temp.class);
                motCell.style.borderLeftWidth = '5px';
                motCell.style.borderLeftStyle = 'solid';
                motCell.style.textAlign = 'left'; 
                motCell.style.paddingLeft = '15px';

                const scoreCell = row.insertCell();
                scoreCell.textContent = essai.score.toFixed(2).replace('.', ',');
                scoreCell.classList.add('score-cell', scoreColorClass);
                scoreCell.style.textAlign = 'center';

                const tempCell = row.insertCell();
                tempCell.innerHTML = `<span class="${temp.class}">${temp.text}</span>`;
                tempCell.style.textAlign = 'center';
                
                tempFragment.appendChild(row);
            });
            
            tbody.appendChild(tempFragment);
            mettreAJourGraphique();

            const resultsDiv = document.querySelector('.results');
            if (resultsDiv) {
                resultsDiv.scrollTop = 0; 
            }
        }
        
        function mettreAJourGraphique() {
            const ctx = document.getElementById('scoreChart').getContext('2d');
            const scores = essais.map(e => e.score);
            const tentatives = essais.map((e, index) => index + 1);

            if (chartInstance) { chartInstance.destroy(); }
            
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: tentatives,
                    datasets: [{
                        label: 'Progression du Score',
                        data: scores,
                        borderColor: isChallengeMode ? '#ff9800' : '#00bcd4', 
                        backgroundColor: isChallengeMode ? 'rgba(255, 152, 0, 0.15)' : 'rgba(0, 188, 212, 0.15)',
                        tension: 0.4,
                        fill: true
                    },
                    {
                        label: 'Objectif (1000)',
                        data: Array(scores.length).fill(1000),
                        borderColor: '#4caf50', 
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { 
                            min: 0, max: 1000, 
                            title: { display: true, text: 'Score S√©mantique', color: '#aaaaaa', font: { weight: '600' } },
                            ticks: { color: '#aaaaaa' },
                            grid: { color: '#333333' } 
                        },
                        x: { 
                            title: { display: true, text: 'Tentative', color: '#aaaaaa', font: { weight: '600' } },
                            ticks: { color: '#aaaaaa' },
                            grid: { color: '#333333' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { 
                            backgroundColor: 'rgba(51, 51, 51, 0.9)',
                            titleColor: '#f0f0f0',
                            bodyColor: '#f0f0f0',
                            titleFont: { weight: '600' },
                            bodyFont: { weight: '500' },
                            callbacks: { 
                                label: function(context) { return `Score: ${context.parsed.y.toFixed(2)}`; } 
                            } 
                        }
                    }
                }
            });
        }
        
        function sauvegarderMeilleurScore() {
            if (isChallengeMode || !partieTerminee) return;
            const key = `semantique_infini_bestscore_${currentLevel}`;
            const bestScoreActuel = parseInt(localStorage.getItem(key)) || Infinity;
            if (totalEssais < bestScoreActuel) {
                localStorage.setItem(key, totalEssais.toString());
                afficherMeilleurScore();
                if (bestScoreActuel !== Infinity) {
                    alert(`Nouveau Record pour le mot "${motSecret.toUpperCase()}" ! ${totalEssais} tentatives.`);
                }
            }
        }

        function afficherMeilleurScore() {
            if (isChallengeMode || currentGame !== 'semantique') {
                document.getElementById('bestScoreDisplay').classList.add('hidden');
                return;
            }
            document.getElementById('bestScoreDisplay').classList.remove('hidden');
            const key = `semantique_infini_bestscore_${currentLevel}`;
            const bestScore = localStorage.getItem(key);
            const displayElement = document.getElementById('bestScoreValue');

            if (bestScore) {
                displayElement.textContent = bestScore;
                displayElement.style.color = (parseInt(bestScore) <= 5) ? '#4caf50' : '#ffeb3b';
            } else {
                displayElement.textContent = "--";
                displayElement.style.color = '#ffeb3b';
            }
        }
        
        function resetProgress() {
            if (confirm("√ätes-vous s√ªr de vouloir r√©initialiser TOUTE votre progression dans le mode Niveaux (y compris les meilleurs scores) ?")) {
                for(let i = 0; i < SEQUENCE_MOTS_SECRETS.length; i++) {
                     localStorage.removeItem(`semantique_infini_essais_${i}`);
                     localStorage.removeItem(`semantique_infini_bestscore_${i}`); 
                }
                localStorage.removeItem('semantique_infini_level');
                currentLevel = 0;
                chargerProgression();
                alert("Progression r√©initialis√©e au Mot Secret N¬∞1.");
            }
        }
        
        function passerAuMotSuivant() {
            if (!partieTerminee) return; 
            if (currentLevel + 1 >= SEQUENCE_MOTS_SECRETS.length) {
                currentLevel = 0; 
                alert("S√©rie Compl√©t√©e ! Vous recommencez au Mot Secret N¬∞1.");
            } else {
                currentLevel++;
            }
            localStorage.setItem('semantique_infini_level', currentLevel.toString());
            chargerProgression(); 
        }

        function searchFriend() {
            const searchInput = document.getElementById('friendSearchInput');
            const resultsDiv = document.getElementById('searchResults');
            const query = searchInput.value.trim();
            resultsDiv.innerHTML = '';
            
            if (!query) {
                resultsDiv.innerHTML = '<p class="social-info" style="color:#888;">Veuillez entrer un pseudo √† rechercher.</p>';
                return;
            }

            resultsDiv.innerHTML = '<p class="social-info" style="color:#00bcd4;"><i class="fa-solid fa-spinner fa-spin"></i> Recherche en cours...</p>';

            setTimeout(() => {
                const myUsername = localStorage.getItem('semantique_infini_username');
                
                if (query.toLowerCase() === myUsername.toLowerCase() || query.toLowerCase() === "joueur2") {
                    const friendName = (query.toLowerCase() === myUsername.toLowerCase()) ? `${myUsername} (Vous)` : query;
                    const statusColor = (query.toLowerCase() === myUsername.toLowerCase()) ? '#ff9800' : '#4caf50';
                    
                    resultsDiv.innerHTML = `
                        <div class="friend-result" style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; padding: 10px 0;">
                            <span class="friend-name"><i class="fa-solid fa-user" style="color:${statusColor}; margin-right: 5px;"></i> ${friendName}</span>
                            <span class="friend-status" style="color: ${statusColor};"><i class="fa-solid fa-circle-dot"></i> En ligne</span>
                            <button class="new-game-button" onclick="proposerDefi('${friendName}')" style="padding: 5px 10px; font-size: 14px;">D√©fier</button>
                        </div>
                    `;
                } 
                else if (query.length > 0) {
                     resultsDiv.innerHTML = `
                        <p class="social-info" style="color:#f44336;">Aucun joueur correspondant au pseudo "${query}" trouv√©.</p>
                        <p class="social-info" style="margin-top: 15px; font-size: 12px; color:#666;">**NOTE :** Cette fonctionnalit√© n√©cessite un serveur web r√©el pour lier les joueurs.</p>
                    `;
                }

                searchInput.value = ''; 

            }, 1000); 
        }

        function proposerDefi(ami) {
            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = `
                <div class="challenge-message" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border: 1px solid #ff9800; text-align: center;">
                    <p style="font-weight: 700; color:#ffeb3b;">D√©fi envoy√© √† **${ami}** ! ‚öîÔ∏è</p>
                    <p style="font-weight: 400; font-size: 13px; margin-top: 8px; color: #ccc;">
                        Mot secret choisi pour ce d√©fi : **${MOT_DEFI.toUpperCase()}**.
                        Vous allez jouer maintenant. ${ami} devra battre votre score !
                    </p>
                    <button class="new-game-button" onclick="lancerDefi()" style="margin-top: 15px; background-color: #ff9800; color: #1a1a1a;">Commencer le D√©fi</button>
                </div>
            `;
            if (ami.includes('(Vous)')) {
                 resultsDiv.querySelector('button').textContent = "Lancer le D√©fi (Local)";
            }
        }

        function lancerDefi() {
            motSecret = MOT_DEFI;
            isChallengeMode = true;
            essais = []; 
            totalEssais = 0;
            partieTerminee = false;

            document.getElementById('levelTitle').textContent = `‚öîÔ∏è D√©fi en Ligne : Mot ${MOT_DEFI.toUpperCase()} ‚öîÔ∏è`;
            
            mettreAJourUIJeu(false);
            afficherResultats();
            
            document.getElementById('socialPanel').classList.add('hidden');
            document.getElementById('exitChallengeButton').classList.remove('hidden'); 
            document.getElementById('normalGameActionButtons').classList.add('hidden'); 
            document.getElementById('bestScoreDisplay').classList.add('hidden'); 
            document.getElementById('wordInput').focus();
        }

        function terminerDefi() {
            const scoreDefi = totalEssais;
            alert(`D√©fi termin√© en ${scoreDefi} tentatives ! Votre score a √©t√© envoy√©. Le mot secret √©tait : ${motSecret}.`);
            
            isChallengeMode = false;
            chargerProgression();
            
            document.getElementById('socialPanel').classList.remove('hidden');
            document.getElementById('searchResults').innerHTML = '<p class="social-info" style="color:#888;">D√©fi termin√©. Cherchez un nouvel ami ou reprenez les niveaux.</p>';
            
            document.getElementById('exitChallengeButton').classList.add('hidden'); 
            document.getElementById('normalGameActionButtons').classList.remove('hidden'); 
            document.getElementById('bestScoreDisplay').classList.remove('hidden');
        }
        
        function quitterDefi() {
            if (confirm("√ätes-vous s√ªr de vouloir abandonner le d√©fi en cours ? Vos tentatives ne seront pas sauvegard√©es comme score de d√©fi.")) {
                isChallengeMode = false;
                chargerProgression();
                
                document.getElementById('socialPanel').classList.remove('hidden');
                document.getElementById('exitChallengeButton').classList.add('hidden'); 
                document.getElementById('normalGameActionButtons').classList.remove('hidden'); 
                document.getElementById('bestScoreDisplay').classList.remove('hidden');
            }
        }


        window.onload = loadProfile;
    </script>

</body>
</html>
